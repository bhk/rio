# Design Log


## Continuation Lines vs. Nested Blocks

Python and Haskell solutions for this are inelegant.

Haskell 2D syntax is specified as a transformation of the token stream,
generating `{`, `;`, and `}` tokens when not supplied by the programmer.  It
relies on keywords to introduce blocks and lookahead to close blocks.
Roughly:

 1. Generate a "{" token after `let`, `where`, `do`, or `of` (if one is not
    explicitly given) and set the current indentation level to the
    indentation of the next "lexeme".

 2. Generate a ";" when the start of line continues the "current"
    indentation level.

 3. Generate a "}" on dedent, or when it fixes a parsing error. (!)

Python 2D syntax rules are described in terms of pre-processing that joins
lines and emits INDENT and DEDENT tokens before traditional parsing.
Roughly:

 1. Do explicit line joining (trailing `\`)

 2. Do implicit line joining (unmatched `(`, `{`, or `[`)

 3. Convert increasing/decreasing indentation to INDENT and DEDENT tokens.


Python indentation guidelines from PEP-8:

 - Indent multiples of 4 spaces.

 - PEP-8: indent continuations *more* than a following nested block
   (except maybe with `if` statements).

 - Don't use explicit line joining (trailling `\`), when instead you can use
   parens to force implicit joining.  Use explicit line joining when
   necessary (e.g. `with`, `assert`).

 - Break lines *before* a binary operator.


For Rio, we considered distinguishing continuation lines from blocks based
on syntax at the end of the line preceding the block or continuation line.
Possibilities include:

  a) `\` ==> continuation.  [Ugly.]

  b) `:` ==> block.  [Dictionary syntax could produce false-positives.  Ugly
     for function bodies.  Odd-looking when used to include blocks in other
     inline expressions.]

  c) (`=>` | `then:` | ...) ==> block.  [This would forbid continuation
     lines after `=>`, and greatly restrict where blocks could appear.]

  d) (`block:` | `then:` | ...) ==> block.  `block:` would introduce a block
     anywhere within an expression, including function bodies.  [Still a bit
     inelegant to begin functions with `f = (x) => block:`.  Also, consider
     the conflict with structure elements named "block" or "then".]

Instead, we examine the indented line itself.  In Rio, it is easy to
identify "clauses": lines that must be followed vertically by other lines,
such as `if`, `loop`, and assignments.  When an indented line is a clause,
it initiates a block.  Otherwise, we treat it as a continuation line.  (An
"indented line" is one indented further than the current block; it is not
necessarily indented further than a preceding continuation line.)


## Random Notes

 - tab = error; continue as if expanded

 - single-space increase an error;  non-matching dedent an error

 - comment indentation ignored (?)

 - trailing (invisible) whitespace is never significant!

 - `if` appears only in 2D block

 - In mathematics, an equation broken across lines will show an operator at
   the start of continuation lines.  "=" will be attached to the first line.

 - When auto-wrapping: break with lowest precedence operators first.


## Parser Design

A conventional parser type signature for Rio would look something like this:

    parse: String -> (AST | Errors)

Where AST describes an expression, and Error describes a set of errors.  We
get one of the other.

This is inadequate for a live programming environment, where we want to be
able to identify and flag errors without losing all thee information about
the other, valid, parts of the program.  We want to be able to highlight
syntax, allow value exploration, and enhance editing.  For example, changing
the name of a variable in its definition will automatically update the other
references to that variable, and editing within a comment can leverage rich
text formatting features.

SCAM's parser reports errors *in* the parse tree.  It always returns an AST,
which is passed through later phases of compilation that transform the tree,
and may in turn add their own error nodes.  The final result is then
traversed to detect error nodes and display messages before generating an
executable.  This works nicely, but it would become more awkward when we try
to accommodate comments and more error resiliency in the parsing.

Instead, we use:

    parse: String -> (AST, OOB)

OOB contains "out-of-band" data -- anything outside of what naturally fits
in an expression, like comments, extraneous text, invalid characters, and so
on.

Errors may manifest in two ways.  First, an invalid or missing expression
will result in a corresponding error-like AST node as necessary to construct
a well-formed AST strcture.  This will be handled by the evaluator when and
if the expression is encountered.  Second, an OOB entry describes the error
for immediate display in the IDE or terminal output.

Using peg.lua, the AST information is returned via the conventional
"captured values" paradigm, while OOB data is stored in the parser state
that propagates across sequential matches.


## Core Evaluator

The core evaluator (`clEval` in interp.lua) is summarized here in a
hypothetical future Lua dialect:

    clEval = (node, env) =>
       eval = newNode => clEval(newNode, env)

       match node:
           CL.Val(value) -> value
           CL.Arg(name) -> env[name]
           CL.Fun(params, body) -> V.Fun(env, params, body)
           CL.App(fn, args) -> match fn:
               V.Nat(name) -> natives[name](args.map(eval))
               V.Fun(fenv, params, body) ->
                   assert args.count == params.count
                   clEval(body, fenv.bind(params, args.map(eval)))
           CL.Bra(cond, then, else) -> match eval(cond):
               V.Bool(b) -> b ? eval(then) : eval(else)
