Current
=======

 - E: replace `activate` with `use`?
 - rop: Open -> Call; Update -> Result; Close -> Drop
 - rop: use new serialization described in rop.md
 - rop: pass thunks & use remotely
 - do not kill server when WS client disconnects
 - rop: protect against malicious peers
 - use button in browser(s) to increment the counter
 - rop: on shutdown, close observers
 - I: deal with leaks (see below)
 - grid: repeating background?
 - grid: demo vertical & horizontal scrolling
 - drag: leverage `listen` from e.js?
 - demo: Demo needn't/shoudn't be `posn: abs`
 - demo: provide buttons for un-render / re-render
 - eventDemo/dragStream: capture vs. document listener
 - Validate "clean" install using "npm update"
 - Revisit comments with TBO (To-Be-Optimized)


Cleanup
----

intern:  memofn(f)(...a) --> (() => f(...a))
Important when used as an argument or return value from a cell.

I.wrap : use memofn

I.wrap : don't automatically use() cell?


Root Cell
----

Root cell = code executed outside of any cell update.

Important for E usage, etc., during module loading.

The root cell is different...
 * we cannot recalculate it
 * input cells must be retained indefinitely (for side-effects only)
 * input cells are always live, and "void".
 * warn of use() of cell outside of update
 * warn of cell that returns non-null/undefined to root

I.activate is simply I.use in root cell


"Leaks" in i.js
====

   Cell (object) Lifetime vs. Cell (node) Liveness

   A cell is often constructed and used in different cells.  When
   constructed, it represents a *potential* node in the dependency graph.
   Only when and where it is later *used* does it become a "live" node in
   the graph.  Once deactivated it returns to being a potential node, and it
   could be activated again.  A live cell will have one or more outputs
   (cells that use it), a result value, and a known set of inputs.

   At present, each memoized cell remembers its own key, and when it is
   deactivated, it removes itself from the cache, allowing it to be
   collected.  This is not an ideal way of doing this, because (a) it
   remains in memory and could be re-activated, and (b) the memo cache is
   global, so some cell other than its original creator might obtain a
   different cell instead of the extant matching one, leaving us with two
   "twins".  [This would still conforms to a more conservative
   using-cell-scoped memoization guarantee, but by allowing greater scope
   this allows for some indeterminacy.]

   Ultimately, cell memoization should be done via ordinary memoization, and
   cleaned up with onDrop handlers and reference counting, so that it will
   remain in memory while *any* of its creator cells remain.

   Also, interned values should be recovered in the same way.  intern.js
   should implement the refcounting, but not depend on i.js.  i.js should
   re-export the leak-free versions.


Longer-term
=====

 * Ultimately we want a reactive FS veneer.  It should make it easy to avoid
   race conditions & locking, or provide an alternative (temporary
   duplication).  For example, changing a song title may require
   modifying/inserting 20 bytes near the end of a 3MB file, but if the file
   has been modified since our read, we could corrupt it.  In the imperative
   model one has to deal with the same problems, but languages and libraries
   in that model are ill-equipped to provide a generic solution to race
   condition problem.

 * PVS: View state that should persist beyond the lifetime of the view --
   not part of the model (the data being viewed) and not part of the view
   class (all instances).  [E.g.: column widths.]  Perhaps this could be
   "automatically" arrived at by the view, based on its "location" -- that
   is, where in the DOM tree it is rendered, and in which application.
   Better yet, its location within an app would be determined more nicely by
   non-DOM parent nodes that exist for addressing purposes.  The current
   e.js model (creation of DOM nodes when views are created) means we cannot
   know *where* we are in the tree until some unknown later point in time.
