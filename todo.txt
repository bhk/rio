TODO

* Unimplemented language features:
  - recursive definitions (forward declarations)
  - type constructors
  - `where`
  - For
  - destructuring assignment with "else:" clause
  - Act
  - short-circuiting `or` & `and`
  - Vector & record equality
  - String syntax: `\xXX` and `\u{X...}`
  - `'` suffixes in variable names (shadowing avoidance)
  - dictionaries/hashmaps

* Going "full lambda": implementing Rio values as IFun
   - Rio "function" => IFun that expects an ArgBundle argument
   - Other values => IFun that expects property name.
        fenv holds instance & class?  `eval` will bind arg to @0,
        so it must conform to the env interface.  Non-function
        values ("native data") could appear at @1, @2, ...
   - This makes behaviors IFun's, so this is best left until we
     have user-defined behavior and know what it looks like.

* Visualize execution
  - collect execution trace
  - capture start & end of elements

* riodoc: concepts.txt --> concepts.md
  1. [[a b c]]  -->  [a b c](#a-b-c)
  2. Broken link detection
  3. "See also: ..."
  4. Index
  5. Comments


---- Long-term

 * "P1" (Phase 1) language definition
 * P1 "bootstrap" interpreter (JavaScript)
    - parse & walk AST
    - minimal set of OS bindings
 * P2 interpreter/compiler (written in Rio P1, supports P2 superset)
    - compiles to Wasm
    - obsoletes bootstrap
    - may leak memory: okay for self-hosting, target programs
      are faster than when interpreted by P1.
 * P3 interpreter/compiler (built using P2)
    - more than self-hosting: non-leaking, clean semantics
 * Choose native VM: Wasmtime, Wasmer, ?
 * OS (WASI?) bindings
 * Web Server
 * P3+: Richer data structuring, lazy/parallel/etc., ...
 * IDE
   - display values (or `pending...`) [computed in parallel VM]
