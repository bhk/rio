TODO

* Unimplemented language features:
  - Manifest variables: true, false, ...
  - Let (other than `=`) & aliasing detection
  - Missing
  - For, Loop, LoopWhile, While
  - recursive definitions (forward declarations)
  - Vectors: `==`, `!=`
  - Records: `==`, `!=`
  - short-circuiting `or` & `and`
  - `$`
  - `.?`
  - `<!`
  - assert
  - type constructors
  - `match`
  - Act
  - String syntax: `\xXX` and `\u{X...}`

* Remove negative literals

* Going "full lambda": implementing Rio values as CFun
   - Rio "function" => CFun that expects an ArgBundle argument
   - Other values => CFun that expects property name.
        fenv holds instance & class?  `eval` will bind arg to @0,
        so it must conform to the env interface.  Non-function
        values ("native data") could appear at @1, @2, ...
   - This makes behaviors IFun's, so this is best left until we
     have user-defined behavior and know what it looks like.

* Visualize execution
  - collect execution trace
  - capture start & end of elements

* Record construction alternative approach in IL: first construct type (from
  const data) *then* instantiate?

* riodoc: concepts.txt --> concepts.md
  1. [[a b c]]  -->  [a b c](#a-b-c)
  2. Broken link detection
  3. "See also: ..."
  4. Index
  5. Comments


---- Long-term

 * "P1" (Phase 1) language definition
 * P1 "bootstrap" interpreter (Lua)
    - parse & walk AST
    - may leak memory (no "free")
    - minimal set of OS bindings
 * P2 interpreter/complier (written in Rio P1, supports P2 superset)
    - compiles to Wasm
    - non-leaking (refcounting)
    - obsoletes bootstrap
 * Choose native VM: Wasmtime, Wasmer, ?
 * OS (WASI?) bindings
 * Web Server
 * P3+: Richer data structuring, lazy/parallel/etc., ...
 * IDE
   - display values (or `pending...`) [computed in parallel VM]
