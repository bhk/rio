TODO

* Unimplemented language features:
  - recursive definitions (forward declarations)
  - type constructors
  - `where`
  - For
  - destructuring assignment with "else:" clause
  - Act
  - short-circuiting `or` & `and`
  - Vector & record equality
  - String syntax: `\xXX` and `\u{X...}`
  - `'` suffixes in variable names (shadowing avoidance)
  - dictionaries/hashmaps
  - disallow re-binding `true`, `false`, `break`, `repeat`
     a) trap at parse time?
     b) use an IErr "wrapper" of the Fn expression?
  - treat `match` as a statement (no match => rest of block)
  - allow match cases to `break`, `repeat`, and re-bind loop vars

* Visualize execution
  - collect execution trace
  - capture start & end of elements

* riodoc: concepts.txt --> concepts.md
  1. [[a b c]]  -->  [a b c](#a-b-c)
  2. Broken link detection
  3. "See also: ..."
  4. Index
  5. Comments


---- Long-term

 * "P1" (Phase 1) language definition
 * P1 "bootstrap" interpreter (JavaScript)
    - parse & walk AST
    - minimal set of OS bindings
 * P2 interpreter/compiler (written in Rio P1, supports P2 superset)
    - compiles to Wasm
    - obsoletes bootstrap
    - may leak memory: okay for self-hosting, target programs
      are faster than when interpreted by P1.
 * P3 interpreter/compiler (built using P2)
    - more than self-hosting: non-leaking, clean semantics
 * Choose native VM: Wasmtime, Wasmer, ?
 * OS (WASI?) bindings
 * Web Server
 * P3+: Richer data structuring, lazy/parallel/etc., ...
 * IDE
   - display values (or `pending...`) [computed in parallel VM]
